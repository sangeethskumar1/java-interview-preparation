1.  What are the new features introduced in Java 11
        Local-Variable Type Inference (var):    Introduced the var keyword to infer the type of local variables automatically
        HTTP Client API:                        A new API for making HTTP requests, replacing the older HttpURLConnection
        Enhanced Performance:                   Various performance improvements, including enhancements to the G1 Garbage Collector
        Removed Features:                       Deprecated and removed features like the Applet support, Nashorn JavaScript Engine(came with java8)

2.  What are the new features introduced in Java 17
        Enhanced Performance:                   Various performance improvements, including enhancements to the G1 Garbage Collector and the introduction of the Shenandoah Garbage Collector
        New Features:                           Records

3.  What Are Records in java
        Records are a special kind of class in Java designed to hold immutable data
        They automatically provide implementations for common methods such as equals(), hashCode(), and toString()
        This helps in reducing boilerplate code for simple data carrier classes

4.  What is the use of Optional class even though we have to use Optional.isPresent() in our use cases
        Expresses Intent:                       Using Optional clearly expresses the possibility of a value being absent, making the code more readable and understandable. When a method returns an Optional, it indicates that the return value might be empty, and the caller should handle it appropriately
        Reduces Null Pointer Exceptions:        Optional provides methods to handle the absence of values without resorting to null checks. This can help avoid NullPointerException, which is a common source of runtime errors in Java.
        Provides Fluent API:                    Optional offers a set of functional-style methods that can make code more concise and expressive:
                                                isPresent(): Checks if a value is present.
                                                ifPresent(): Executes a callback if a value is present
                                                orElse(): Returns a default value if the value is absent
                                                orElseGet(): Returns a value from a Supplier if the value is absent
                                                orElseThrow(): Throws an exception if the value is absent
                                                map(): Transforms the value if present
                                                flatMap(): Transforms the value and flattens the result

5.  What is Functional Interface ? What is the use of Functional Interface

6.  How Spring Boot Works. Explain AutoConfiguration

7.  Is it mandatory to add @Repository Annotation in Spring Boot Repository Class.? Will it work with @Component
        No. @Component can also be used instead, but it will lose advantages specific to @Repository. Recommended to use @Repository tag since
            Semantics: @Repository indicate that a class is DAO class.
            Exception Translation: It automatically provides translation of database-specific exceptions into Spring's DataAccessException hierarchy.

8.  What are Stereotype Annotations ?
        Stereotype annotations indicate that the class is managed by spring container. Its part of Spring Component Scan mechanism.
        All Stereotype Annotations are subtype of @Component.
        @Component
        @Service
        @Repository
        @Controller
        @RestController

9.  What is the difference between @Bean & @Component
        They have different purposed
        @Bean
            Comes under @Configuration class to define beans
            Applies to methods within @Configuration class
            Used for defining beans programmatically with more control over their instantiation, configuration, and initialization
        @Component
            Mark a class as a Spring-managed component and for automatic detection and configuration during component scanning
            Applied directly to class definitions
        Key Differences
            Location: @Bean is applied to methods in configuration classes, while @Component is applied to classes.
            Discovery: @Bean requires explicit declaration, whereas @Component is automatically detected through classpath scanning.
            Usage: @Bean gives more fine-grained control over the bean creation process, whereas @Component simplifies bean registration.

10. What is Spring Application Context

11. Explain Spring Package Scan

12. Explain Solid Principles
        Single Responsibility Principle
            A class must have only one responsibility
        Open Close Principle
            Classes/ Functions must be Open for Extension & Closed for Modification
        Liskov's Substitution Principle
            Superclass objects should be replaceable with child class objects without affecting correctness of program
        Interface Segregation Principle
            Clients should not be forced to implement interfaces that are not required
        Dependency Inversion Principle
            High level modules and low level modules should depend on Abstractions

13.